scale_color_manual(values = party_colors) +
# Add titles and labels
labs(
title = "Distribution of Aggregated GDP Per Capita (GDPC) by Winner (Spread Jitter)",
x = "Winner (Political Party)",
y = "Aggregated GDP Per Capita ($)",
color = "Winner"
) +
# Apply a clean theme
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
legend.position = "none"
)
# 2. Sort globally by aggregated_gdp descending
bolivia_sorted <- bolivia_plot %>%
arrange(desc(aggregated_gdp))
# 3. Treemap with *global* area scaling
ggplot(bolivia_sorted, aes(
area = aggregated_gdp,
fill = winner,
label = label
)) +
geom_treemap(color = "white", size = 0.25) +
geom_treemap_text(
aes(
label = ifelse(aggregated_gdp > quantile(aggregated_gdp, 0.90), label, "")
),
place = "center",
grow = TRUE,
reflow = TRUE,
color = "white",
fontface = "bold",
size = 2
) +
scale_fill_manual(
values = c("PDC" = "#207677", "LIBRE" = "#fe0201"),
name = NULL
) +
facet_wrap(~winner, ncol = 2, scales = "fixed") +
theme_void(base_size = 14) +
theme(
strip.text = element_text(
face = "bold",
size = 16,
color = "white",
margin = margin(0, 0, 5, 0)
),
strip.background = element_rect(
fill = c("#000000"),
color = NA
),
panel.spacing = unit(0, "lines"),
legend.position = "none",
plot.title = element_text(face = "bold", size = 18, hjust = 0.5)
) +
labs(
title = "PDC vs. LIBRE — Municipal Share of GDP in Bolivia",
caption = "Source: Your dataset | Design inspired by Brookings Metro"
)
get_country_borders <- function() {
main_path <- getwd()
borders <- geodata::gadm(
country = "COL",
level = 0,
path = main_path
) |>
sf::st_as_sf()
return(borders)
}
get_state_borders <- function() {
main_path <- getwd()
borders <- geodata::gadm(
country = "COL",
level = 1,
path = main_path
) |>
sf::st_as_sf()
return(borders)
}
get_municipality_borders <- function() {
main_path <- getwd()
borders <- geodata::gadm(
country = "COL",
level = 2,
path = main_path
) |>
sf::st_as_sf()
return(borders)
}
country_sf <- get_country_borders()
state_sf <- get_state_borders()
municipality_sf <- get_municipality_borders()
target_crs <- st_crs(country_sf)
# Paths to your files
csv_file <- "0_25deg/final_GDP_0_25deg_postadjust_pop_dens_0_adjust.csv"
shp_file <- "0_25deg/shapefile/geom_0_25deg.shp"
# Load shapefile and CSV
bfi_geom <- sf::st_read(shp_file)
setwd("D:/Projects/sub-national-GDP")
# Paths to your files
csv_file <- "0_25deg/final_GDP_0_25deg_postadjust_pop_dens_0_adjust.csv"
shp_file <- "0_25deg/shapefile/geom_0_25deg.shp"
# Load shapefile and CSV
bfi_geom <- sf::st_read(shp_file)
bfi_data <- read_csv(csv_file)
bfi_geom <- bfi_geom |>
filter(iso == "COL")
bfi_data <- bfi_data |>
filter(iso == "COL" & year == 2021)
# Make sure 'cell_id' exists and types match
bfi_geom$cell_id <- as.numeric(bfi_geom$cell_id)  # or as.character() below, depending which works
bfi_data$cell_id <- as.numeric(bfi_data$cell_id)
# bfi_data          bfi_geom
# cell_id           cell_id
# subcell_id        sbcell_d
# subcell_id_0_25   s__0_25
#### 4. Merge datasets ####
# The join is: bfi_geom |> left_join(bfi_data, by = join_by_cols)
# Format: "column_in_bfi_geom" = "column_in_bfi_data"
join_by_cols_final <- c(
"cell_id" = "cell_id",
"sbcll_d" = "subcell_id",           # Corrected column name from the diagnostic check
"s__0_25" = "subcell_id_0_25"
)
# Perform the left join
bfi_merged_sf <- bfi_geom |>
left_join(bfi_data, by = join_by_cols_final) |>
# Filter based on the variable we are about to use (cell_GDPC_current_USD)
filter(!is.na(cell_GDPC_current_USD))
#### 5. Data Processing for Plotting ####
bfi_merged_sf$scaled_gdp <- bfi_merged_sf$cell_GDPC_current_USD * 1e9
# source_var is "scaled_gdp"
source_var <- "scaled_gdp"
n_classes <- 10
epsilon <- 1e-9
# Use the combined data for break calculation
gdp_values <- bfi_merged_sf[[source_var]]
# 1. Calculate breaks using QUANTILE with jitter (to handle tied values)
set.seed(42)
gdp_values_jittered <- gdp_values + runif(length(gdp_values), 0, epsilon)
breaks_gdp <- classInt::classIntervals(
var = gdp_values_jittered,
n = n_classes,
style = "quantile"
)$brks
breaks_gdp[1] <- min(gdp_values)
breaks_gdp[n_classes + 1] <- max(gdp_values)
n_unique_classes <- n_classes
# 2. Format the labels using the breaks
labels_gdp <- sapply(
1:n_unique_classes,
function(i) {
# No 'digits = 0' here
start <- floor(breaks_gdp[i])
end_raw <- floor(breaks_gdp[i + 1])
if (i == n_unique_classes) {
end <- floor(end_raw)
# For the last interval, use [a, b]
return(paste0(start, " – ", end))
} else {
# For all other intervals, use [a, b) (subtract epsilon for display)
end <- floor(end_raw - epsilon)
return(paste0(start, " – ", end))
}
}
)
# 3. Apply the classification to BOTH datasets
# Apply to Bolivia data
bfi_merged_sf <- bfi_merged_sf |>
mutate(
gdp_decile = cut(!!sym(source_var), breaks = breaks_gdp, labels = labels_gdp, include.lowest = T, right = TRUE)
)
# Reverse the order of the factor levels/labels for the desired legend display (same as before)
bfi_merged_sf$gdp_decile <- factor(bfi_merged_sf$gdp_decile, levels = rev(labels_gdp))
# 4. Define the color palette (order remains lightest to darkest for internal use)
gdp_colors <- c(
"#FFFF66", "#FFD700", "#FFA500", "#FF4500", "#CD0000", # Lighter colors
"#8B008B", "#483D8B", "#191970", "#000080", "#000033"  # Darker colors
)
# Ensure 10 colors are used if 10 classes were calculated
if (length(gdp_colors) != n_unique_classes) {
gdp_colors <- colorRampPalette(gdp_colors)(n_unique_classes)
}
labels_gdp_raw <- sapply(
1:n_unique_classes,
function(i) {
start_value <- floor(breaks_gdp[i])
start <- format(start_value, big.mark = ",", nsmall = 0)
end_raw <- breaks_gdp[i + 1]
if (i == n_unique_classes) {
end_value <- floor(end_raw)
end <- format(end_value, big.mark = ",", nsmall = 0)
return(paste0(start, " – ", end))
} else {
# For all other intervals, subtract epsilon and then floor for display
end_value <- floor(end_raw - epsilon)
end <- format(end_value, big.mark = ",", nsmall = 0)
return(paste0(start, " – ", end))
}
}
)
plot_title_EN <- "colombia GDP per Capita (2021) by 0.25°x 0.25° cells"
plot_subtitle_EN <- "Current Prices (USD)"
plot_caption_EN <- "©2025 Pablo Hernández Borges | pablohernandezb.dev\nData: Rossi-Hansberg & Zhang (2025)"
# Define the border color for the squares
grid_border_color <- "grey70"
# Create the map
colombia_map <- ggplot() +
# 1. Add the main grid data layer (Venezuela)
geom_sf(
data = bfi_merged_sf,
aes(fill = gdp_decile),
# FIX: Change color from NA to a light gray
color = grid_border_color,
size = 0.075 # This controls the thickness of the border line
) +
# 2. Add the Esequibo grid data layer (Guyana data for Esequibo)
# geom_sf(
#   data = bfi_esequibo_sf,
#   aes(fill = gdp_decile),
#   # FIX: Change color from NA to a light gray
#   color = grid_border_color,
#   size = 0.075
# ) +
# 3. Add state borders (Venezuela only)
geom_sf(
data = state_sf,
fill = NA,
color = "grey30",
linewidth = 0.5
) +
# 4. Add the Esequibo claimed border (distinct visual style)
# geom_sf(
#   data = esequibo_sf,
#   fill = NA,
#   color = "red",
#   linetype = "dashed",
#   linewidth = 1
# ) +
# 5. Add country border for the outline
geom_sf(
data = country_sf,
fill = NA,
color = "black",
linewidth = 1
) +
# 6. Apply the custom color palette
scale_fill_manual(
values = rev(gdp_colors),
name = "GDP per capita (USD)",
drop = FALSE
) +
# 7. Add labs and theme
labs(
title = plot_title_EN,
subtitle = plot_subtitle_EN,
caption = plot_caption_EN
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 16),
plot.subtitle = element_text(size = 12),
plot.caption = element_text(size = 10, hjust = 0),
legend.position = "right",
legend.title = element_text(face = "bold"),
axis.text = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.background = element_rect(fill = "white", color = "white", linewidth = 1)
)
# Display the map
print(colombia_map)
# Save the map (optional)
ggsave("colombia_gdp_map.png", plot = colombia_map, width = 8, height = 6, dpi = 300)
plot_title_EN <- "Colombia GDP per Capita (2021) by 0.25°x 0.25° cells"
plot_subtitle_EN <- "Current Prices (USD)"
plot_caption_EN <- "©2025 Pablo Hernández Borges | pablohernandezb.dev\nData: Rossi-Hansberg & Zhang (2025)"
# Define the border color for the squares
grid_border_color <- "grey70"
# Create the map
colombia_map <- ggplot() +
# 1. Add the main grid data layer (Venezuela)
geom_sf(
data = bfi_merged_sf,
aes(fill = gdp_decile),
# FIX: Change color from NA to a light gray
color = grid_border_color,
size = 0.075 # This controls the thickness of the border line
) +
# 2. Add the Esequibo grid data layer (Guyana data for Esequibo)
# geom_sf(
#   data = bfi_esequibo_sf,
#   aes(fill = gdp_decile),
#   # FIX: Change color from NA to a light gray
#   color = grid_border_color,
#   size = 0.075
# ) +
# 3. Add state borders (Venezuela only)
geom_sf(
data = state_sf,
fill = NA,
color = "grey30",
linewidth = 0.5
) +
# 4. Add the Esequibo claimed border (distinct visual style)
# geom_sf(
#   data = esequibo_sf,
#   fill = NA,
#   color = "red",
#   linetype = "dashed",
#   linewidth = 1
# ) +
# 5. Add country border for the outline
geom_sf(
data = country_sf,
fill = NA,
color = "black",
linewidth = 1
) +
# 6. Apply the custom color palette
scale_fill_manual(
values = rev(gdp_colors),
name = "GDP per capita (USD)",
drop = FALSE
) +
# 7. Add labs and theme
labs(
title = plot_title_EN,
subtitle = plot_subtitle_EN,
caption = plot_caption_EN
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 16),
plot.subtitle = element_text(size = 12),
plot.caption = element_text(size = 10, hjust = 0),
legend.position = "right",
legend.title = element_text(face = "bold"),
axis.text = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.background = element_rect(fill = "white", color = "white", linewidth = 1)
)
# Display the map
print(colombia_map)
# Save the map (optional)
ggsave("colombia_gdp_map.png", plot = colombia_map, width = 8, height = 6, dpi = 300)
# Ensure the combined grid data has a unique ID for each cell
bfi_all_grid_sf <- bind_rows(
bfi_merged_sf |> mutate(grid_id = 1:n())
) |>
select(grid_id, scaled_gdp, geometry)
# Create an empty raster from one of the grid cells
# Assuming 0.25 degree resolution, you might need to adjust based on exact data.
# Get resolution from your shapefile's bbox or a sample cell
resolution_x <- diff(st_bbox(bfi_all_grid_sf)$xlim) / (max(bfi_all_grid_sf$grid_id) / 100) # Rough estimate
resolution_y <- diff(st_bbox(bfi_all_grid_sf)$ylim) / (max(bfi_all_grid_sf$grid_id) / 100) # Rough estimate
# A better way: create a raster template from the geometry directly
# Assuming your grid cells are regular squares, you can get the extent
# and resolution directly from one cell's bounding box.
first_cell_bbox <- st_bbox(bfi_all_grid_sf[1,])
cell_res_x <- first_cell_bbox$xmax - first_cell_bbox$xmin
cell_res_y <- first_cell_bbox$ymax - first_cell_bbox$ymin
# Create a raster from the `scaled_gdp` values
# First, create an empty raster that covers the extent of all your grid data
r_template <- terra::rast(
ext(bfi_all_grid_sf),
resolution = c(cell_res_x, cell_res_y),
crs = st_crs(bfi_all_grid_sf)$wkt
)
# Now, rasterize the sf object to get the scaled_gdp values into the raster
# Ensure your sf object has a column named 'scaled_gdp'
gdp_raster <- terra::rasterize(
x = bfi_all_grid_sf,
y = r_template,
field = "scaled_gdp",
fun = "mean" # If multiple polygons fall into one cell, take the mean
)
# --------------------------------------------------------------------------
# NEW: Perform spatial aggregation for states and municipalities
# --------------------------------------------------------------------------
# Ensure the combined grid data has a unique ID for each cell
# This assumes bfi_merged_sf and bfi_esequibo_sf are already prepared from previous steps
bfi_all_grid_sf <- bind_rows(
bfi_merged_sf |> mutate(grid_id = 1:n())
) |>
select(grid_id, scaled_gdp, geometry)
# Check 1: Ensure the combined data is still valid geometry
if (any(!st_is_valid(bfi_all_grid_sf)) | any(st_is_empty(bfi_all_grid_sf))) {
bfi_all_grid_sf <- st_make_valid(bfi_all_grid_sf)
}
# Check 2: Get resolution and extent for the raster template
# Assuming your grid cells are regular squares, get resolution from one cell's bounding box.
first_cell_bbox <- st_bbox(bfi_all_grid_sf[1,])
cell_res_x <- first_cell_bbox$xmax - first_cell_bbox$xmin
cell_res_y <- first_cell_bbox$ymax - first_cell_bbox$ymin
# Create an empty raster that covers the extent of all your grid data
r_template <- terra::rast(
ext(bfi_all_grid_sf),
resolution = c(cell_res_x, cell_res_y),
crs = st_crs(bfi_all_grid_sf)$wkt
)
# Check 3 (CRITICAL): Rasterize the sf object to get the scaled_gdp values into the raster
# Ensure the geometry column is named 'geom' if the rasterize fails
gdp_raster <- terra::rasterize(
x = bfi_all_grid_sf,
y = r_template,
field = "scaled_gdp",
fun = "mean"
)
# Check 4: Verify the raster was created
if (inherits(gdp_raster, "SpatRaster")) {
message("✅ gdp_raster created successfully.")
} else {
stop("❌ ERROR: Failed to create gdp_raster object.")
}
state_gdp_avg <- exact_extract(
x = gdp_raster,
y = state_sf,
fun = "mean",
append_cols = c("NAME_1", "GID_1")
) |>
rename(aggregated_gdp = mean)
# c) Join Venezuelan results to the base SF object
state_sf_colombia_agg <- state_sf |>
left_join(state_gdp_avg, by = c("NAME_1", "GID_1")) |>
select(starts_with("NAME_"), starts_with("GID_"), aggregated_gdp, geometry) # Use 'geometry'
# e) Combine all final state data
state_sf_colombia <- bind_rows(
state_sf_colombia_agg
) |>
filter(!is.na(aggregated_gdp))
View(municipality_sf)
# c) Join Venezuelan results to the base SF object
state_sf_colombia_agg <- state_sf |>
left_join(state_gdp_avg, by = c("NAME_1", "GID_1")) |>
select(starts_with("NAME_"), starts_with("GID_"), aggregated_gdp, geometry) # Use 'geometry'
# e) Combine all final state data
state_sf_colombia <- bind_rows(
state_sf_colombia_agg
) |>
filter(!is.na(aggregated_gdp))
# a) Aggregate Venezuelan municipalities (excluding the Esequibo entry)
colombia_municipalities <- municipality_sf
municipality_gdp_avg <- exact_extract(
x = gdp_raster,
y = colombia_municipalities,
fun = "mean",
append_cols = c("NAME_2", "GID_2", "NAME_1", "GID_3")
) |>
rename(aggregated_gdp = mean)
state_gdp_avg <- exact_extract(
x = gdp_raster,
y = state_sf,
fun = "mean",
append_cols = c("NAME_1", "GID_1")
) |>
rename(aggregated_gdp = mean)
# c) Join Venezuelan results to the base SF object
state_sf_colombia_agg <- state_sf |>
left_join(state_gdp_avg, by = c("NAME_1", "GID_1")) |>
select(starts_with("NAME_"), starts_with("GID_"), aggregated_gdp, geometry) # Use 'geometry'
# e) Combine all final state data
state_sf_colombia <- bind_rows(
state_sf_colombia_agg
) |>
filter(!is.na(aggregated_gdp))
# a) Aggregate Venezuelan municipalities (excluding the Esequibo entry)
colombia_municipalities <- municipality_sf
municipality_gdp_avg <- exact_extract(
x = gdp_raster,
y = colombia_municipalities,
fun = "mean",
append_cols = c("NAME_2", "GID_2", "NAME_1", "GID_3")
) |>
rename(aggregated_gdp = mean)
state_gdp_avg <- exact_extract(
x = gdp_raster,
y = state_sf,
fun = "mean",
append_cols = c("NAME_1", "GID_1")
) |>
rename(aggregated_gdp = mean)
# c) Join Venezuelan results to the base SF object
state_sf_colombia_agg <- state_sf |>
left_join(state_gdp_avg, by = c("NAME_1", "GID_1")) |>
select(starts_with("NAME_"), starts_with("GID_"), aggregated_gdp, geometry) # Use 'geometry'
# e) Combine all final state data
state_sf_colombia <- bind_rows(
state_sf_colombia_agg
) |>
filter(!is.na(aggregated_gdp))
# a) Aggregate Venezuelan municipalities (excluding the Esequibo entry)
colombia_municipalities <- municipality_sf
municipality_gdp_avg <- exact_extract(
x = gdp_raster,
y = colombia_municipalities,
fun = "mean",
append_cols = c("NAME_2", "GID_2", "NAME_1")
) |>
rename(aggregated_gdp = mean)
# b) Join Venezuelan results to the base SF object
municipality_sf_colombia_agg <- colombia_municipalities |>
left_join(municipality_gdp_avg, by = c("NAME_2", "GID_2", "NAME_1")) |>
select(starts_with("NAME_"), starts_with("GID_"), aggregated_gdp, geometry) # Use 'geometry'
# d) Combine all final municipality data
municipality_sf_aggregated <- bind_rows(
municipality_sf_colombia_agg
) |>
filter(!is.na(aggregated_gdp))
save(bolivia_sf, file = "bolivia_sf.RData")
